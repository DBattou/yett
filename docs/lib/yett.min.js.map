{"version":3,"file":"yett.min.js","sources":["../../src/index.js"],"sourcesContent":["// Variables //\nlet blacklistedPatterns = window.YETT_BLACKLIST\nlet whitelistedPatterns = window.YETT_WHITELIST\nconst TYPE_ATTRIBUTE = 'javascript/blocked'\n\n// Backup of the blacklisted script nodes\nlet blackListedScripts = []\n\nconst isOnBlacklist = (src, type) => (\n    src &&\n    (!type || type !== TYPE_ATTRIBUTE) &&\n    (\n        (!blacklistedPatterns || blacklistedPatterns.some(pattern => pattern.test(src))) &&\n        (!whitelistedPatterns || whitelistedPatterns.every(pattern => !pattern.test(src)))\n    )\n)\n\n/* 1st part - setup a mutation observer to track DOM insertion */\n\nconst observer = new MutationObserver(mutations => {\n    mutations.forEach(({ addedNodes }) => {\n        for(let i = 0; i < addedNodes.length; i++) {\n            const node = addedNodes[i]\n            // For each added script tag\n            if(node.nodeType === 1 && node.tagName === 'SCRIPT') {\n                const src = node.src\n                const type = node.type\n                // If the src is inside the blacklist and is not inside the whitelist\n                if(isOnBlacklist(src, type)) {\n                    // We backup a copy of the script node\n                    blackListedScripts.push(node.cloneNode())\n\n                    // Blocks inline script execution in Safari & Chrome\n                    node.type = TYPE_ATTRIBUTE\n\n                    // Firefox has this additional event which prevents scripts from beeing executed\n                    const beforeScriptExecuteListener = function (event) {\n                        // Prevent only marked scripts from executing\n                        if(node.getAttribute('type') === TYPE_ATTRIBUTE)\n                            event.preventDefault()\n                        node.removeEventListener('beforescriptexecute', beforeScriptExecuteListener)\n                    }\n                    node.addEventListener('beforescriptexecute', beforeScriptExecuteListener)\n\n                    // Remove the node from the DOM\n                    node.parentElement.removeChild(node)\n                }\n            }\n        }\n    })\n})\n\n// Starts the monitoring\nobserver.observe(document.documentElement, {\n    childList: true,\n    subtree: true\n})\n\n/* 2nd part - Monkey patch the createElement method to prevent dynamic scripts from executing */\n\nconst originalDescriptors = {\n    src: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'src'),\n    type: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'type')\n}\nconst createElementBackup = document.createElement\n\ndocument.createElement = function(...args) {\n    // If this is not a script tag, bypass\n    if(args[0].toLowerCase() !== 'script')\n        return createElementBackup.bind(document)(...args)\n\n    const scriptElt = createElementBackup.bind(document)(...args)\n\n    // Use the prototype descriptors\n    Object.defineProperties(scriptElt, {\n        'src': {\n            get() {\n                return originalDescriptors.src.get.call(this)\n            },\n            set(value) {\n                if(isOnBlacklist(value, scriptElt.type)) {\n                    scriptElt.type = TYPE_ATTRIBUTE\n                }\n                return originalDescriptors.src.set.call(this, value)\n            }\n        },\n        'type': {\n            set(value) {\n                return originalDescriptors.type.set.call(\n                    this,\n                    isOnBlacklist(scriptElt.src, scriptElt.type) ?\n                        TYPE_ATTRIBUTE :\n                        value\n                )\n            }\n        }\n    })\n\n    // Monkey patch the setAttribute function so that the setter is called instead\n    scriptElt.setAttribute = function(name, value) {\n        if(name === 'type' || name === 'src')\n            scriptElt[name] = value\n        else\n            HTMLScriptElement.prototype.setAttribute.call(scriptElt, name, value)\n    }\n\n    return scriptElt\n}\n\nconst unblockCheck = function(script) {\n    const src = script.getAttribute('src')\n    return (\n        (blacklistedPatterns && blacklistedPatterns.every(entry => !entry.test(src))) ||\n        (whitelistedPatterns && whitelistedPatterns.some(entry => entry.test(src)))\n    )\n}\n\n// Unblocks all (or a selection of) blacklisted scripts.\nexport const unblock = function(...scriptUrls) {\n\n    if(scriptUrls.length < 1) {\n        blacklistedPatterns = []\n        whitelistedPatterns = []\n    } else {\n        if(blacklistedPatterns) {\n            blacklistedPatterns = blacklistedPatterns.filter(pattern =>\n                scriptUrls.every(url => !pattern.test(url))\n            )\n        }\n        if(whitelistedPatterns) {\n            whitelistedPatterns = [\n                ...whitelistedPatterns,\n                ...scriptUrls\n                    .map(url => {\n                        const escapedUrl = url.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n                        const permissiveRegexp = '.*' + escapedUrl + '.*'\n                        if(!whitelistedPatterns.find(p => p.toString() === permissiveRegexp.toString())) {\n                            return new RegExp(permissiveRegexp)\n                        }\n                        return null\n                    })\n                    .filter(Boolean)\n            ]\n        }\n    }\n\n\n    // Parse existing script tags with a marked type\n    const tags = document.querySelectorAll(`script[type=\"${TYPE_ATTRIBUTE}\"]`)\n    for(let i = 0; i < tags.length; i++) {\n        const script = tags[i]\n        if(unblockCheck(script)) {\n            script.type = 'application/javascript'\n            blackListedScripts.push(script)\n            script.parentElement.removeChild(script)\n        }\n    }\n\n    // Exclude 'whitelisted' scripts from the blacklist and append them to <head>\n    blackListedScripts = blackListedScripts.reduce((acc, script) => {\n        if(unblockCheck(script)) {\n            const scriptNode = document.createElement('script')\n            scriptNode.setAttribute('src', script.src)\n            scriptNode.setAttribute('type', 'application/javascript')\n            document.head.appendChild(scriptNode)\n            return acc\n        }\n        return [...acc, script]\n    }, [])\n\n    // Disconnect the observer if the blacklist is empty for performance reasons\n    if(blacklistedPatterns && blacklistedPatterns.length < 1) {\n        observer.disconnect()\n    }\n}\n"],"names":["blacklistedPatterns","window","YETT_BLACKLIST","whitelistedPatterns","YETT_WHITELIST","blackListedScripts","isOnBlacklist","src","type","some","pattern","test","every","observer","MutationObserver","forEach","addedNodes","i","node","nodeType","tagName","push","cloneNode","addEventListener","beforeScriptExecuteListener","event","getAttribute","preventDefault","removeEventListener","parentElement","removeChild","length","observe","document","documentElement","originalDescriptors","Object","getOwnPropertyDescriptor","HTMLScriptElement","prototype","createElementBackup","createElement","args","toLowerCase","bind","scriptElt","defineProperties","get","call","this","value","set","setAttribute","name","unblockCheck","script","entry","scriptUrls","filter","url","map","permissiveRegexp","replace","find","p","toString","RegExp","Boolean","tags","querySelectorAll","reduce","acc","scriptNode","head","appendChild","disconnect"],"mappings":"oTACIA,EAAsBC,OAAOC,eAC7BC,EAAsBF,OAAOG,eAI7BC,KAEEC,EAAgB,SAACC,EAAKC,UACxBD,KACEC,GAPiB,uBAOTA,MAEJR,GAAuBA,EAAoBS,KAAK,mBAAWC,EAAQC,KAAKJ,SACxEJ,GAAuBA,EAAoBS,MAAM,mBAAYF,EAAQC,KAAKJ,OAM9EM,EAAW,IAAIC,iBAAiB,cACxBC,QAAQ,oBAAGC,IAAAA,sBACTC,OACEC,EAAOF,EAAWC,MAEH,IAAlBC,EAAKC,UAAmC,WAAjBD,EAAKE,QAAsB,KAC3Cb,EAAMW,EAAKX,IACXC,EAAOU,EAAKV,QAEfF,EAAcC,EAAKC,GAAO,GAENa,KAAKH,EAAKI,eAGxBd,KA9BF,uBAuCEe,iBAAiB,sBANc,SAA9BC,EAAwCC,GAjC3C,uBAmCIP,EAAKQ,aAAa,SACjBD,EAAME,mBACLC,oBAAoB,sBAAuBJ,OAK/CK,cAAcC,YAAYZ,MAxBnCD,EAAI,EAAGA,EAAID,EAAWe,OAAQd,MAA9BA,OAgChBJ,EAASmB,QAAQC,SAASC,4BACX,WACF,IAKb,IAAMC,OACGC,OAAOC,yBAAyBC,kBAAkBC,UAAW,YAC5DH,OAAOC,yBAAyBC,kBAAkBC,UAAW,SAEjEC,EAAsBP,SAASQ,cAErCR,SAASQ,cAAgB,sCAAYC,4CAEJ,WAA1BA,EAAK,GAAGC,cACP,OAAOH,EAAoBI,KAAKX,uBAAaS,OAE3CG,EAAYL,EAAoBI,KAAKX,uBAAaS,iBAGjDI,iBAAiBD,8BAGLV,EAAoB5B,IAAIwC,IAAIC,KAAKC,oBAExCC,UACG5C,EAAc4C,EAAOL,EAAUrC,UACpBA,KA9EP,sBAgFA2B,EAAoB5B,IAAI4C,IAAIH,KAAKC,KAAMC,wBAI9CA,UACOf,EAAoB3B,KAAK2C,IAAIH,KAChCC,KACA3C,EAAcuC,EAAUtC,IAAKsC,EAAUrC,MAvFpC,qBAyFC0C,SAOVE,aAAe,SAASC,EAAMH,GACxB,SAATG,GAA4B,QAATA,EAClBR,EAAUQ,GAAQH,EAElBZ,kBAAkBC,UAAUa,aAAaJ,KAAKH,EAAWQ,EAAMH,IAGhEL,GAGX,IAAMS,EAAe,SAASC,OACpBhD,EAAMgD,EAAO7B,aAAa,cAE3B1B,GAAuBA,EAAoBY,MAAM,mBAAU4C,EAAM7C,KAAKJ,MACtEJ,GAAuBA,EAAoBM,KAAK,mBAAS+C,EAAM7C,KAAKJ,gBAKtD,sCAAYkD,yCAE5BA,EAAW1B,OAAS,eAIhB/B,MACuBA,EAAoB0D,OAAO,mBAC7CD,EAAW7C,MAAM,mBAAQF,EAAQC,KAAKgD,QAG3CxD,kBAEQA,KACAsD,EACEG,IAAI,gBAEKC,EAAmB,KADNF,EAAIG,QAAQ,sBAAuB,QACT,YACzC3D,EAAoB4D,KAAK,mBAAKC,EAAEC,aAAeJ,EAAiBI,aAG7D,KAFI,IAAIC,OAAOL,KAIzBH,OAAOS,qBAOlBC,EAAOnC,SAASoC,sDACdpD,EAAI,EAAGA,EAAImD,EAAKrC,OAAQd,IAAK,KAC3BsC,EAASa,EAAKnD,GACjBqC,EAAaC,OACL/C,KAAO,2BACKa,KAAKkC,KACjB1B,cAAcC,YAAYyB,MAKpBlD,EAAmBiE,OAAO,SAACC,EAAKhB,MAC9CD,EAAaC,GAAS,KACfiB,EAAavC,SAASQ,cAAc,mBAC/BW,aAAa,MAAOG,EAAOhD,OAC3B6C,aAAa,OAAQ,mCACvBqB,KAAKC,YAAYF,GACnBD,oBAEAA,IAAKhB,SAIjBvD,GAAuBA,EAAoB+B,OAAS,KAC1C4C"}